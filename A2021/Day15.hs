-- |
-- Module      : Day15
-- Description : Solution to AOC 2021 Day 15: Chiton
-- Maintainer  : <xsebek@fi.muni.cz>
--
-- <https://adventofcode.com/2021/day/15>
module Day15 where

import Algorithm.Search (dijkstra, aStar)
import Data.Char (digitToInt)
import Data.Map (Map)
import Data.Map qualified as Map
import Data.Maybe (fromJust)
import Linear (V2 (..))

-- | Solution to Day 15.
main15 :: FilePath -> IO ()
main15 f = do
  input <- parse <$> readFile f
  print $ solve1 input
  print $ solve2 input

type P2 = V2 Int

type Grid = Map P2 Int

parse :: String -> Grid
parse = Map.fromList . indexYX . map (map digitToInt) . lines
 where
  indexYX :: [[a]] -> [(P2, a)]
  indexYX l = [(V2 x y, a) | (y, ls) <- zip [0 ..] l, (x, a) <- zip [0 ..] ls]

inBound :: (P2, P2) -> P2 -> Bool
inBound (V2 lx ly, V2 rx ry) (V2 x y) = lx <= x && x <= rx && ly <= y && y <= ry

adjancent :: Grid -> P2 -> [P2]
adjancent !g !p = filter (inBound gbounds) $ map (p +) plusMinus
 where
  plusMinus = [V2 1 0, V2 0 1, V2 0 (-1), V2 (-1) 0]
  gbounds = (V2 0 0,) . fst $ Map.findMax g

minimalPath :: P2 -> P2 -> Grid -> (Int, [P2])
minimalPath start end g = fromJust $ aStar -- (state -> f state) (state -> state -> cost) (state -> cost) (state -> Bool) state
 (adjancent g)
 (\_ np -> g Map.! np)
 (\v -> sum . abs $ end - v)
 (== end)
 start

lrCorner :: Grid -> P2
lrCorner = fst . Map.findMax

minimalPathCorners :: Grid -> (Int, [P2])
minimalPathCorners g = minimalPath (V2 0 0) (lrCorner g) g

-- >>> let p = snd (minimalPathCorners example) in prettyGrid' 1 $ Map.filterWithKey (\k _ -> k `elem` p) example
-- ..........
-- 1.........
-- 2136511...
-- ......15..
-- .......1..
-- .......13.
-- ........2.
-- ........3.
-- ........21
-- .........1
solve1 :: Grid -> Int
solve1 = fst . minimalPathCorners

repeatGrid :: Int -> Grid -> Grid
repeatGrid n g = Map.unions $ map gPlus xyN
 where
  nList = take n [0 ..]
  xyN = V2 <$> nList <*> nList
  plus10 !x !y = ((x + y - 1) `mod` 9) + 1
  mv = lrCorner g + V2 1 1
  gPlus v = Map.mapKeysMonotonic (v * mv +) $ Map.map (plus10 $ sum v) g

-- >>> let g = repeatGrid 5 example; p = snd (minimalPathCorners g) in prettyGrid' 1 $ Map.filterWithKey (\k _ -> k `elem` p) g
-- ..................................................
-- 1.................................................
-- 2136511...........................................
-- ......15..........................................
-- .......1..........................................
-- .......13.2421....................................
-- ........212..1123532..............................
-- ...................1..............................
-- ...................2342...........................
-- ......................332.........................
-- ........................1.........................
-- ........................61........................
-- .........................44.......................
-- ..........................4.......................
-- ..........................1.......................
-- ..........................2.......................
-- ..........................5.......................
-- ..........................4.......................
-- ..........................2.......................
-- ..........................7.......................
-- ..........................52......................
-- ...........................12.....................
-- ............................6.....................
-- ............................14825.................
-- ................................2.................
-- ................................6.................
-- ................................15................
-- .................................19762............
-- .....................................1............
-- .....................................1............
-- .....................................41...........
-- ......................................4...........
-- ......................................8...........
-- ......................................3614........
-- .........................................2........
-- .........................................1........
-- .........................................137......
-- ...........................................3......
-- ...........................................181....
-- .............................................223..
-- ...............................................6..
-- ...............................................5..
-- ...............................................21.
-- ................................................5.
-- ................................................9.
-- ................................................2.
-- ................................................1.
-- ................................................2.
-- ................................................1.
-- ................................................79
solve2 :: Grid -> Int
solve2 = solve1 . repeatGrid 5

prettyGrid' :: Int -> Grid -> IO ()
prettyGrid' width g = prettyGrid width (fst $ Map.findMax g) g

prettyGrid :: Int -> P2 -> Grid -> IO ()
prettyGrid width (V2 mx my) g = mapM_ putStrLn cgrid
 where
  cgrid = [concat [lpad width . maybe "." show $ g Map.!? V2 x y | x <- [0 .. mx]] | y <- [0 .. my]]
  lpad m xs = replicate (m - length xs) ' ' ++ xs

example :: Grid
example =
  parse . unlines $
    [ "1163751742"
    , "1381373672"
    , "2136511328"
    , "3694931569"
    , "7463417111"
    , "1319128137"
    , "1359912421"
    , "3125421639"
    , "1293138521"
    , "2311944581"
    ]